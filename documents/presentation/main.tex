%!TEX program = lualatex

\PassOptionsToPackage{french}{babel}
\PassOptionsToPackage{french}{translator}
\PassOptionsToPackage{table,svgnames}{xcolor}
\documentclass[aspectratio=169,11pt]{beamer}

%----------------------------------------
% Packages
%----------------------------------------
\usepackage{etoolbox}
\usepackage{ifxetex}
\usepackage{ifluatex}
\usepackage[T1]{fontenc}
\ifboolexpr{bool{xetex} or bool{luatex}}{%
	\usepackage{fontspec}
}{%
	\usepackage[utf8]{inputenc}
}
\usepackage{babel}
\usepackage{translator}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{dsfont}
\usepackage{braket}
\usepackage{array}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[justification=centering]{caption}
\usepackage{float}
\usepackage[mode=tex]{standalone}
\usepackage{pgf}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\usepackage{tikz}
\usepackage{tikzpeople}
\usepackage[backend=bibtex,bibstyle=ieee,citestyle=numeric-comp]{biblatex}

%----------------------------------------
% Theme
%----------------------------------------

\usetheme[nofirafonts,numbering=progressbar]{focus}
% \usetheme[numbering=fullbar]{focus}
% \usetheme[numbering=none]{focus}
% \definecolor{main}{RGB}{92, 138, 168}
% \definecolor{background}{RGB}{240, 247, 255}

% remove navigation symbols.
\beamertemplatenavigationsymbolsempty{}

%\setbeamercovered{transparent}

%----------------------------------------
% Informations
%----------------------------------------

\title{Set Cover Problem}
\subtitle{}
\author{Benoît Cortier\\Maxime Pinard}
\institute[UQAC]{Université du Québec à Chicoutimi\\555 Boulevard de l'Université, Chicoutimi, QC G7H 2B1}
\date[18/04/2019]{18 Avril 2019}

%\keywords{}
\subject{Set Cover Problem}
%\logo{\includegraphics[width=0.12\textwidth]{logos/UQAC}}

%----------------------------------------
% Bibliography
%----------------------------------------

\bibliography{../references}
\nocite{*}

%----------------------------------------
% Figures
%----------------------------------------

% Common file
\input{../figures/figures_common}

% Figures folder
\graphicspath{{../figures/}}

%----------------------------------------
% Tables
%----------------------------------------

% Common file
\input{../tables/tables_common}

%----------------------------------------
% Plots
%----------------------------------------

\pgfplotsset{
	table/search path={../plots},
}

%----------------------------------------
% Document
%----------------------------------------
\begin{document}
	\begin{frame}
		\titlepage
	\end{frame}
	% \begin{frame}{Sommaire}
	% 	\tableofcontents
	% \end{frame}

	%% définition du problème

	\begin{frame}
		\frametitle{Définition du « Set Cover Problem » (SCP)}
		\begin{itemize}
			\item l'un des 21 problèmes NP-complets de \citeauthor{Karp1972}~\cite{Karp1972}.
			\item NP-complet au sens fort~\cite{garey2002computers}.
			\item Soit l'ensemble univers \(U = \{u_1, u_2, u_3, \dots, u_m\}\) et une famille \(S = \{s_1, s_2, \dots, s_n\}\) de sous-ensembles de \(U\).
			\item[\(\rightarrow\)] Trouver une sous-famille de \(S\) la plus petite possible permettant de couvrir chaque élément de \(U\) au moins une fois.
			\item \(e\) est couvert par un sous-ensemble \(A\) si \(e \in A\).
			\vfill
			\item En associant un coût positif \(c_i\) à chaque sous-ensemble, on obtient le problème de couverture d'ensemble pondéré ou \emph{Weighted Set Covering Problem} (WSCP)~\cite{Vazirani2003}
		\end{itemize}
	\end{frame}

	%% exemple minimal

	\begin{frame}
		\frametitle{Exemple minimal}
		\centering
		\includegraphics[width=0.75\linewidth]{scp_example}%
	\end{frame}

	%% complexité NP-complétude

	\begin{frame}
		\frametitle{Réductions de Karp}
		\centering
		\includegraphics[width=\linewidth]{karp_reduction_tree}%
	\end{frame}

	%% état de l'art

	\begin{frame}
		\frametitle{État de l'art}
		Méthodes exactes~:
		\begin{itemize}
			\item le plus efficace~: méthodes branch-and-bound en calculant les bornes inférieures à l'aide d'une relaxation du problème en programmation linéaire.~\cite{caprara2000algorithms}
			\item Algorithme de \citeauthor{Beasley1987}: le nœud racine utilise la solution du programme linéaire relaxé, puis les bornes inférieures sont calculées à l'aide de la relaxation lagrangienne.~\cite{Beasley1987}
		\end{itemize}
		Méthodes approchées voraces~:
		\begin{itemize}
			\item L'algorithme vorace standard de \citeauthor{Johnson:1973:AAC:800125.804034} pour le problème de couverture d'ensemble non pondéré. L'algorithme prend simplement le sous-ensemble qui couvre le plus d'éléments à chaque étape jusqu'à obtenir une solution valide. Complexité en \(O(mn)\).~\cite{Johnson:1973:AAC:800125.804034}
			\item \citeauthor{Goldschmidt:1993:MGH:177276.177287}: méthode où l'on applique des
				algorithmes approchés et exacts.
				On utilise l'algorithme vorace de Johnson jusqu'à obtenir une taille maximale de 2.
				On peut trouver la solution optimale pour une taille maximale de 2 en un temps linéaire.~\cite{Goldschmidt:1993:MGH:177276.177287}
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{État de l'art}
		Méthodes approchées métaheuristiques~:
		\begin{itemize}
			\item \citeauthor{Beasley1990}: à chaque itération d'un gradient~: un ensemble \(S\) est initialisé avec les sous-ensembles sélectionnés par la solution de la relaxation lagrangienne. Puis, pour chaque point non couvert par \(S\), le sous ensemble avec le coût original le plus faible est ajouté à \(S\). Pour finir, les différents sous-ensembles de \(S\) sont considérés par ordre de coût original décroissant et on enlève le sous-ensemble \(j\) si \(S \backslash \{j\}\) est toujours une solution valide.~\cite{Beasley1990}	
			\item \citeauthor{jacobs1995lsh}: approche basée sur le recuit simulé.~\cite{jacobs1995lsh}
				\begin{itemize}
					\item Solution initiale \(S\) est générée par un algorithme vorace.
					\item On execute un certain nombre d'itérations de recuit simulé~:
					on choisi un sous-ensemble dans \(S\) aléatoirement
					et on l'enlève, puis on complète de manière vorace de manière à obtenir une autre solution valide \(S'\).
					\item On décide si on garde ou non \(S'\).
				\end{itemize}
			\item \citeauthor{Afif1995}: méthode basée sur l'algorithme du flot de Ford-Fulkerson \(\rightarrow\) temps polynomial. Il s'agit d'effectuer une transformation du problème en un graphe de flot à résoudre par une variante de l'algorithme.~\cite{Afif1995}
		\end{itemize}
	\end{frame}

	%% représentation du problème

	\begin{frame}
		\centering TODO
	\end{frame}

	%% méthodes exactes

	\begin{frame}
		\centering TODO
	\end{frame}

	%% méthodes approchées

	\begin{frame}
		\centering TODO
	\end{frame}

	%% OR-library

	\begin{frame}
		\centering TODO
	\end{frame}

	%% comparaison avec les méthodes approchées

	\begin{frame}
		\centering TODO
	\end{frame}

	\begin{frame}
		\frametitle{Exemple: figure}
		\centering
		\includegraphics[width=0.75\linewidth]{scp_example}%
	\end{frame}
	\begin{frame}
		\frametitle{Exemple: table}
		{
			\centering
			\footnotesize
			\input{../tables/orlibrary_scp_problem_sets}
		}
	\end{frame}
	\begin{frame}
		\frametitle{Exemple: plot}
		\centering
		\input{../plots/permutations_generators_ram}%
	\end{frame}
	\section*{Questions?}
		\begin{frame}[focus]
			Questions?
		\end{frame}
	\appendix
		\begin{frame}[t,allowframebreaks]
			\frametitle{Références}
			\printbibliography[heading=bibintoc]{}
		\end{frame}
\end{document}
