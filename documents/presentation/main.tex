%!TEX program = lualatex

\PassOptionsToPackage{french}{babel}
\PassOptionsToPackage{french}{translator}
\PassOptionsToPackage{table,svgnames}{xcolor}
\documentclass[aspectratio=169,11pt]{beamer}

%----------------------------------------
% Packages
%----------------------------------------
\usepackage{etoolbox}
\usepackage{ifxetex}
\usepackage{ifluatex}
\usepackage[T1]{fontenc}
\ifboolexpr{bool{xetex} or bool{luatex}}{%
	\usepackage{fontspec}
}{%
	\usepackage[utf8]{inputenc}
}
\usepackage{babel}
\usepackage{translator}
\usepackage{lmodern}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathrsfs}
\usepackage{dsfont}
\usepackage{braket}
\usepackage{array}
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[justification=centering]{caption}
\usepackage{float}
\usepackage[mode=tex]{standalone}
\usepackage{pgf}
\usepackage{pgfplots}
\pgfplotsset{compat=newest}
\usepackage{tikz}
\usepackage{tikzpeople}
\usepackage[backend=bibtex,bibstyle=ieee,citestyle=numeric-comp]{biblatex}

%----------------------------------------
% Theme
%----------------------------------------

\usetheme[nofirafonts,numbering=progressbar]{focus}
% \usetheme[numbering=fullbar]{focus}
% \usetheme[numbering=none]{focus}
% \definecolor{main}{RGB}{92, 138, 168}
% \definecolor{background}{RGB}{240, 247, 255}

% remove navigation symbols.
\beamertemplatenavigationsymbolsempty{}

%\setbeamercovered{transparent}

%----------------------------------------
% Informations
%----------------------------------------

\title{Set Cover Problem}
\subtitle{}
\author{Benoît Cortier\\Maxime Pinard}
\institute[UQAC]{Université du Québec à Chicoutimi\\555 Boulevard de l'Université, Chicoutimi, QC G7H 2B1}
\date[18/04/2019]{18 Avril 2019}

%\keywords{}
\subject{Set Cover Problem}
%\logo{\includegraphics[width=0.12\textwidth]{logos/UQAC}}

%----------------------------------------
% Bibliography
%----------------------------------------

\bibliography{../references}
\nocite{*}

%----------------------------------------
% Figures
%----------------------------------------

% Common file
\input{../figures/figures_common}

% Figures folder
\graphicspath{{../figures/}}

%----------------------------------------
% Tables
%----------------------------------------

% Common file
\input{../tables/tables_common}

%----------------------------------------
% Plots
%----------------------------------------

\pgfplotsset{
	table/search path={../plots},
}

%----------------------------------------
% Document
%----------------------------------------
\begin{document}
	\begin{frame}
		\titlepage
	\end{frame}
	% \begin{frame}{Sommaire}
	% 	\tableofcontents
	% \end{frame}

	%% définition du problème

	\begin{frame}
		\frametitle{Définition du « Set Cover Problem » (SCP)}
		\begin{itemize}
			\item l'un des 21 problèmes NP-complets de \citeauthor{Karp1972}~\cite{Karp1972}.
			\item NP-complet au sens fort~\cite{garey2002computers}.
			\item Soit l'ensemble univers \(U = \{u_1, u_2, u_3, \dots, u_m\}\) et une famille \(S = \{s_1, s_2, \dots, s_n\}\) de sous-ensembles de \(U\).
			\item[\(\rightarrow\)] Trouver une sous-famille de \(S\) la plus petite possible permettant de couvrir chaque élément de \(U\) au moins une fois.
			\item \(e\) est couvert par un sous-ensemble \(A\) si \(e \in A\).
			\vfill
			\item En associant un coût positif \(c_i\) à chaque sous-ensemble, on obtient le problème de couverture d'ensemble pondéré ou \emph{Weighted Set Covering Problem} (WSCP)~\cite{Vazirani2003}
		\end{itemize}
	\end{frame}

	%% exemple minimal

	\begin{frame}
		\frametitle{Exemple minimal}
		\centering
		\includegraphics[width=0.75\linewidth]{scp_example}%
	\end{frame}

	%% complexité NP-complétude

	\begin{frame}
		\frametitle{Réductions de Karp}
		\centering
		\includegraphics[width=0.85\linewidth]{karp_reduction_tree}%
	\end{frame}

	%% état de l'art

	\begin{frame}
		\frametitle{État de l'art}
		\begin{block}{Méthodes exactes}
			\begin{itemize}
				\item le plus efficace: méthodes branch-and-bound en calculant les bornes inférieures à l'aide d'une relaxation du problème en programmation linéaire.~\cite{caprara2000algorithms}
				\item Algorithme de \citeauthor{Beasley1987}: le nœud racine utilise la solution du programme linéaire relaxé, puis les bornes inférieures sont calculées à l'aide de la relaxation lagrangienne.~\cite{Beasley1987}
			\end{itemize}
		\end{block}
	\end{frame}
	\begin{frame}
		\frametitle{État de l'art}
		\begin{block}{Méthodes approchées voraces}
			\begin{itemize}
				\item L'algorithme vorace standard de \citeauthor{Johnson:1973:AAC:800125.804034} pour le problème de couverture d'ensemble non pondéré. L'algorithme prend simplement le sous-ensemble qui couvre le plus d'éléments à chaque étape jusqu'à obtenir une solution valide. Complexité en \(O(mn)\).~\cite{Johnson:1973:AAC:800125.804034}
				\item \citeauthor{Goldschmidt:1993:MGH:177276.177287}: méthode où l'on applique des
					algorithmes approchés et exacts.
					On utilise l'algorithme vorace de Johnson jusqu'à obtenir une taille maximale de 2.
					On peut trouver la solution optimale pour une taille maximale de 2 en un temps linéaire.~\cite{Goldschmidt:1993:MGH:177276.177287}
			\end{itemize}
		\end{block}
	\end{frame}

	\begin{frame}
		\frametitle{État de l'art}
		\begin{block}{Méthodes approchées métaheuristiques}
			\begin{itemize}
				\item \citeauthor{Beasley1990}: à chaque itération d'un gradient: un ensemble \(S\) est initialisé avec les sous-ensembles sélectionnés par la solution de la relaxation lagrangienne. Puis, pour chaque point non couvert par \(S\), le sous ensemble avec le coût original le plus faible est ajouté à \(S\). Pour finir, les différents sous-ensembles de \(S\) sont considérés par ordre de coût original décroissant et on enlève le sous-ensemble \(j\) si \(S \backslash \{j\}\) est toujours une solution valide.~\cite{Beasley1990}	
				\item \citeauthor{jacobs1995lsh}: approche basée sur le recuit simulé.~\cite{jacobs1995lsh}
					\begin{itemize}
						\item Solution initiale \(S\) est générée par un algorithme vorace.
						\item On execute un certain nombre d'itérations de recuit simulé:
						on choisi un sous-ensemble dans \(S\) aléatoirement
						et on l'enlève, puis on complète de manière vorace de manière à obtenir une autre solution valide \(S'\).
						\item On décide si on garde ou non \(S'\).
					\end{itemize}
				\item \citeauthor{Afif1995}: méthode basée sur l'algorithme du flot de Ford-Fulkerson \(\rightarrow\) temps polynomial. Il s'agit d'effectuer une transformation du problème en un graphe de flot à résoudre par une variante de l'algorithme.~\cite{Afif1995}
			\end{itemize}
		\end{block}
	\end{frame}

	%% représentation du problème

	\begin{frame}
		\centering TODO
	\end{frame}

	%% Instances de problèmes

	\begin{frame}
		\frametitle{OR-Library}
		\centering TODO
	\end{frame}

	\begin{frame}
		\frametitle{Problèmes générés}
		\centering TODO
	\end{frame}

	%% méthodes exactes
	\section{Méthodes exactes}

	\begin{frame}
		\frametitle{Exemple: plot}
		\centering
		\input{../plots/permutations_generators_ram}%
	\end{frame}

	%% méthodes approchées
	\section{Méthodes approchées}

	\begin{frame}
		\frametitle{Méthodes voraces implémentées (non optimales)}
		\begin{block}{Méthode vorace non pondérée}
			\begin{itemize}
				\item Greedy classique de \citeauthor{Johnson:1973:AAC:800125.804034}: sélection de l'ensemble qui couvre le plus de nouveaux points successivement.
				\item[\alert{\(\blacktriangleright\)}]<2-> Problème \emph{A.1} (optimal: \(253\)), on obtient la solution de coût \alert{\(1444\)}.
			\end{itemize}
		\end{block}
		\begin{block}<3->{Méthode vorace pondérée}
			\begin{itemize}
				\item Greedy basé sur celui de \citeauthor{Johnson:1973:AAC:800125.804034}: on utilise le rapport \(\frac{n}{c}\) avec
					\begin{itemize}
						\item \(n\) le nombre de nouveaux points couverts,
						\item et \(c\) le coût du sous-ensemble.
					\end{itemize}
				\item[\alert{\(\blacktriangleright\)}]<4-> Problème \emph{A.1} (optimal: \(253\)), on obtient cette fois une solution de coût \alert{\(288\)}.
			\end{itemize}
		\end{block}
	\end{frame}

	\begin{frame}
		%\frametitle{Comparaison des méthodes voraces}
		\centering
		\input{../plots/greedy_diff.tex}
	\end{frame}

	\begin{frame}
		\frametitle{Recuit simulé}
		\begin{itemize}
			\item Recuit simulé standard (vu en cours)
			\item On applique un opérateur de voisinage à chaque itération
			\item Si cela améliore la solution, on conserve la solution, sinon on on accepte avec une
				probalité \(e^{\frac{-\Delta}{T}}\) avec \(\Delta\) la différence de coût
				entre la solution courante et la nouvelle solution et \(T\) la température courante.
			\item Nous faisons varier la température uniformément entre deux bornes au fil des itérations.
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{Algorithme génétique}
		\begin{itemize}
			\item Sélection par rang
			\item Recherche locale à l'aide du recuit simulé
			\item Opérateur de croisement: résoudre le problème de façon vorace à l'aide de la méthode vorace pondérée
				sur les sous-ensembles choisis par les deux solutions à croiser uniquement.
		\end{itemize}
	\end{frame}

	\begin{frame}
		\frametitle{Algorithme génétique: procédure}
		\begin{itemize}
			\item On commence par générer une population \(P\) de \(n\) individus aléatoirement.
			\item À chaque itération (ou génération):
				\begin{itemize}
					\item On trie les individus par coût décroissant. L'indice d'un individu correspond alors à son rang.
					\item On supprime les individus on doublon pour favoriser l'exploration. On note \(D\) le nombre de doublons supprimés.
					\item On créer \(n' = n \times t_r\) nouveaux individus à partir de deux parents à chaque fois.
						Les deux parents sont sélectionnés selon leur rang. On applique un opérateur de croisement
						pour obtenir une troisième solution. Cette solution a une probabilité \(t_l\) de subir une
						recherche locale par recuit simulé avec les paramètres \(r_{tmp}\) et \(r_{fin}\) et une probabilité
						\(t_m\) de subir une mutation par opérateur de voisinage.
					\item Les \(n'\) nouveaux individus remplacement les \(n' - D\) pire individus de la génération précédente.
				\end{itemize}
			\item On élémine des sous-ensembles de la meilleure solution trouvée en lançant la procédure vorace pondérée limitée
				aux sous-ensembles choisis par la solution.
			\item On retourne cette solution.
		\end{itemize}
	\end{frame}

	%% comparaison avec les méthodes approchées

	\begin{frame}
		\frametitle{Évaluation des méthodes présentées}
		\begin{block}{Instances d'OR-Library utilisées}
			\begin{itemize}
				\item avec solution optimale: A.1, B.1, C.1., D.1, 4.1, 5.1
				\item sans solution optimale: 6.1.
			\end{itemize}
		\end{block}
		\begin{block}<2->{Ajustement des paramètres par optimisation de boîte noire}
			\begin{itemize}
				\item Algorithme de Mesh Adaptive Directed Search avec le logiciel NOMAD\footnote{{https://sourceforge.net/projects/nomad-bb-opt/}}
				\item Fonctionne autant avec des boîtes noires déterministes qu'avec des boite non-déterministes.
			\end{itemize}
		\end{block}
	\end{frame}
	\begin{frame}
		\frametitle{Évaluation des méthodes présentées}
		\begin{block}{Configuration}
			\begin{itemize}
				\item Algorithme génétique:
					\begin{itemize}
						\item 60 évaluations de boîte noire maximum
						\item l'évaluation dure une minute: on effectue autant de générations que possible durant le temps imparti
					\end{itemize}
				\item Recuit simulé:
					\begin{itemize}
						\item 20 évaluations de boîte noire maximum
						\item \(50\,000\,000\) d'itérations (3 minutes)
						\item solution de départ générée aléatoirement
					\end{itemize}
			\end{itemize}
		\end{block}
	\end{frame}

	\begin{frame}
		\frametitle{Coût des solutions obtenues}
		\centering
		\input{../tables/orlibrary_scp_approached}
	\end{frame}

	\section*{Questions?}
		\begin{frame}[focus]
			Questions?
		\end{frame}
	\appendix
		\begin{frame}[t,allowframebreaks]
			\frametitle{Références}
			\printbibliography[heading=bibintoc]{}
		\end{frame}
\end{document}
